!function (r, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(r.SVGPoints = {}) }(this, function (r) { "use strict"; var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (r) { return typeof r } : function (r) { return r && "function" == typeof Symbol && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r }, t = Object.assign || function (r) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var u in t) Object.prototype.hasOwnProperty.call(t, u) && (r[u] = t[u]) } return r }, u = function (r, e) { var t = {}; for (var u in r) e.indexOf(u) >= 0 || Object.prototype.hasOwnProperty.call(r, u) && (t[u] = r[u]); return t }, n = function (r) { var e = r.type, t = u(r, ["type"]); switch (e) { case "circle": return y(t); case "ellipse": return p(t); case "line": return i(t); case "path": return v(t); case "polygon": return l(t); case "polyline": return d(t); case "rect": return m(t); case "g": return w(t); default: throw new Error("Not a valid shape type") } }, y = function (r) { var e = r.cx, t = r.cy, u = r.r; return [{ x: e, y: t - u, moveTo: !0 }, { x: e, y: t + u, curve: { type: "arc", rx: u, ry: u, sweepFlag: 1 } }, { x: e, y: t - u, curve: { type: "arc", rx: u, ry: u, sweepFlag: 1 } }] }, p = function (r) { var e = r.cx, t = r.cy, u = r.rx, n = r.ry; return [{ x: e, y: t - n, moveTo: !0 }, { x: e, y: t + n, curve: { type: "arc", rx: u, ry: n, sweepFlag: 1 } }, { x: e, y: t - n, curve: { type: "arc", rx: u, ry: n, sweepFlag: 1 } }] }, i = function (r) { var e = r.x1, t = r.x2; return [{ x: e, y: r.y1, moveTo: !0 }, { x: t, y: r.y2 }] }, a = /[MmLlHhVvCcSsQqTtAaZz]/g, o = { A: 7, C: 6, H: 1, L: 2, M: 2, Q: 4, S: 4, T: 2, V: 1, Z: 0 }, s = ["a", "c", "h", "l", "m", "q", "s", "t", "v"], c = function (r) { return -1 !== s.indexOf(r) }, x = ["xAxisRotation", "largeArcFlag", "sweepFlag"], h = function (r) { return r.match(a) }, f = function (r) { return r.split(a).map(function (r) { return r.replace(/[0-9]+-/g, function (r) { return r.slice(0, -1) + " -" }) }).map(function (r) { return r.replace(/\.[0-9]+/g, function (r) { return r + " " }) }).map(function (r) { return r.trim() }).filter(function (r) { return r.length > 0 }).map(function (r) { return r.split(/[ ,]+/).map(parseFloat).filter(function (r) { return !isNaN(r) }) }) }, v = function (r) { for (var e = r.d, t = h(e), u = f(e), n = [], y = void 0, p = 0, i = t.length; p < i; p++) { var a = t[p], s = a.toUpperCase(), v = o[s], l = c(a); if (v > 0) for (var d = u.shift(), b = d.length / v, m = 0; m < b; m++) { var g = n[n.length - 1] || { x: 0, y: 0 }; switch (s) { case "M": var q = (l ? g.x : 0) + d.shift(), w = (l ? g.y : 0) + d.shift(); 0 === m ? (y = { x: q, y: w }, n.push({ x: q, y: w, moveTo: !0 })) : n.push({ x: q, y: w }); break; case "L": n.push({ x: (l ? g.x : 0) + d.shift(), y: (l ? g.y : 0) + d.shift() }); break; case "H": n.push({ x: (l ? g.x : 0) + d.shift(), y: g.y }); break; case "V": n.push({ x: g.x, y: (l ? g.y : 0) + d.shift() }); break; case "A": n.push({ curve: { type: "arc", rx: d.shift(), ry: d.shift(), xAxisRotation: d.shift(), largeArcFlag: d.shift(), sweepFlag: d.shift() }, x: (l ? g.x : 0) + d.shift(), y: (l ? g.y : 0) + d.shift() }); var A = !0, k = !1, F = void 0; try { for (var T, M = x[Symbol.iterator](); !(A = (T = M.next()).done); A = !0) { var S = T.value; 0 === n[n.length - 1].curve[S] && delete n[n.length - 1].curve[S] } } catch (r) { k = !0, F = r } finally { try { !A && M.return && M.return() } finally { if (k) throw F } } break; case "C": n.push({ curve: { type: "cubic", x1: (l ? g.x : 0) + d.shift(), y1: (l ? g.y : 0) + d.shift(), x2: (l ? g.x : 0) + d.shift(), y2: (l ? g.y : 0) + d.shift() }, x: (l ? g.x : 0) + d.shift(), y: (l ? g.y : 0) + d.shift() }); break; case "S": var O = (l ? g.x : 0) + d.shift(), j = (l ? g.y : 0) + d.shift(), P = (l ? g.x : 0) + d.shift(), C = (l ? g.y : 0) + d.shift(), V = {}, H = void 0, L = void 0; g.curve && "cubic" === g.curve.type ? (V.x = Math.abs(g.x - g.curve.x2), V.y = Math.abs(g.y - g.curve.y2), H = g.x < g.curve.x2 ? g.x - V.x : g.x + V.x, L = g.y < g.curve.y2 ? g.y - V.y : g.y + V.y) : (V.x = Math.abs(P - O), V.y = Math.abs(C - j), H = g.x, L = g.y), n.push({ curve: { type: "cubic", x1: H, y1: L, x2: O, y2: j }, x: P, y: C }); break; case "Q": n.push({ curve: { type: "quadratic", x1: (l ? g.x : 0) + d.shift(), y1: (l ? g.y : 0) + d.shift() }, x: (l ? g.x : 0) + d.shift(), y: (l ? g.y : 0) + d.shift() }); break; case "T": var Q = (l ? g.x : 0) + d.shift(), Z = (l ? g.y : 0) + d.shift(), N = void 0, R = void 0; if (g.curve && "quadratic" === g.curve.type) { var _ = { x: Math.abs(g.x - g.curve.x1), y: Math.abs(g.y - g.curve.y1) }; N = g.x < g.curve.x1 ? g.x - _.x : g.x + _.x, R = g.y < g.curve.y1 ? g.y - _.y : g.y + _.y } else N = g.x, R = g.y; n.push({ curve: { type: "quadratic", x1: N, y1: R }, x: Q, y: Z }) } } else { var z = n[n.length - 1] || { x: 0, y: 0 }; z.x === y.x && z.y === y.y || n.push({ x: y.x, y: y.y }) } } return n }, l = function (r) { var e = r.points; return b({ closed: !0, points: e }) }, d = function (r) { var e = r.points; return b({ closed: !1, points: e }) }, b = function (r) { var e = r.closed, u = r.points.split(/[\s,]+/).map(function (r) { return parseFloat(r) }).reduce(function (r, e, t) { return t % 2 == 0 ? r.push({ x: e }) : r[(t - 1) / 2].y = e, r }, []); return e && u.push(t({}, u[0])), u[0].moveTo = !0, u }, m = function (r) { var e = r.height, t = r.rx, u = r.ry, n = r.width, y = r.x, p = r.y; return t || u ? q({ height: e, rx: t || u, ry: u || t, width: n, x: y, y: p }) : g({ height: e, width: n, x: y, y: p }) }, g = function (r) { var e = r.height, t = r.width, u = r.x, n = r.y; return [{ x: u, y: n, moveTo: !0 }, { x: u + t, y: n }, { x: u + t, y: n + e }, { x: u, y: n + e }, { x: u, y: n }] }, q = function (r) { var e = r.height, t = r.rx, u = r.ry, n = r.width, y = r.x, p = r.y, i = { type: "arc", rx: t, ry: u, sweepFlag: 1 }; return [{ x: y + t, y: p, moveTo: !0 }, { x: y + n - t, y: p }, { x: y + n, y: p + u, curve: i }, { x: y + n, y: p + e - u }, { x: y + n - t, y: p + e, curve: i }, { x: y + t, y: p + e }, { x: y, y: p + e - u, curve: i }, { x: y, y: p + u }, { x: y + t, y: p, curve: i }] }, w = function (r) { return r.shapes.map(function (r) { return n(r) }) }, A = function (r) { var e = "", t = 0, u = void 0, n = !0, y = !1, p = void 0; try { for (var i, a = r[Symbol.iterator](); !(n = (i = a.next()).done); n = !0) { var o = i.value, s = o.curve, c = void 0 !== s && s, x = o.moveTo, h = o.x, f = o.y, v = 0 === t || x, l = t === r.length - 1 || r[t + 1].moveTo, d = 0 === t ? null : r[t - 1]; if (v) u = o, l || (e += "M" + h + "," + f); else if (c) { switch (c.type) { case "arc": var b = o.curve, m = b.largeArcFlag, g = void 0 === m ? 0 : m, q = b.rx, w = b.ry, A = b.sweepFlag, k = void 0 === A ? 0 : A, F = b.xAxisRotation; e += "A" + q + "," + w + "," + (void 0 === F ? 0 : F) + "," + g + "," + k + "," + h + "," + f; break; case "cubic": var T = o.curve; e += "C" + T.x1 + "," + T.y1 + "," + T.x2 + "," + T.y2 + "," + h + "," + f; break; case "quadratic": var M = o.curve; e += "Q" + M.x1 + "," + M.y1 + "," + h + "," + f }l && h === u.x && f === u.y && (e += "Z") } else l && h === u.x && f === u.y ? e += "Z" : h !== d.x && f !== d.y ? e += "L" + h + "," + f : h !== d.x ? e += "H" + h : f !== d.y && (e += "V" + f); t++ } } catch (r) { y = !0, p = r } finally { try { !n && a.return && a.return() } finally { if (y) throw p } } return e }, k = function r(t) { var u = []; if (F(t).map(function (r) { var n = r.match, y = r.prop, p = r.required, i = r.type; void 0 === t[y] ? p && u.push(y + " prop is required" + ("type" === y ? "" : " on a " + t.type)) : (void 0 !== i && ("array" === i ? Array.isArray(t[y]) || u.push(y + " prop must be of type array") : e(t[y]) !== i && u.push(y + " prop must be of type " + i)), Array.isArray(n) && -1 === n.indexOf(t[y]) && u.push(y + " prop must be one of " + n.join(", "))) }), "g" === t.type && Array.isArray(t.shapes)) { var n = t.shapes.map(function (e) { return r(e) }); return [].concat.apply(u, n) } return u }, F = function (r) { var e = [{ match: ["circle", "ellipse", "line", "path", "polygon", "polyline", "rect", "g"], prop: "type", required: !0, type: "string" }]; switch (r.type) { case "circle": e.push({ prop: "cx", required: !0, type: "number" }), e.push({ prop: "cy", required: !0, type: "number" }), e.push({ prop: "r", required: !0, type: "number" }); break; case "ellipse": e.push({ prop: "cx", required: !0, type: "number" }), e.push({ prop: "cy", required: !0, type: "number" }), e.push({ prop: "rx", required: !0, type: "number" }), e.push({ prop: "ry", required: !0, type: "number" }); break; case "line": e.push({ prop: "x1", required: !0, type: "number" }), e.push({ prop: "x2", required: !0, type: "number" }), e.push({ prop: "y1", required: !0, type: "number" }), e.push({ prop: "y2", required: !0, type: "number" }); break; case "path": e.push({ prop: "d", required: !0, type: "string" }); break; case "polygon": case "polyline": e.push({ prop: "points", required: !0, type: "string" }); break; case "rect": e.push({ prop: "height", required: !0, type: "number" }), e.push({ prop: "rx", type: "number" }), e.push({ prop: "ry", type: "number" }), e.push({ prop: "width", required: !0, type: "number" }), e.push({ prop: "x", required: !0, type: "number" }), e.push({ prop: "y", required: !0, type: "number" }); break; case "g": e.push({ prop: "shapes", required: !0, type: "array" }) }return e }; r.toPath = function (r) { var e = Array.isArray(r), t = e ? Array.isArray(r[0]) : "g" === r.type, u = e ? r : t ? r.shapes.map(function (r) { return n(r) }) : n(r); return t ? u.map(function (r) { return A(r) }) : A(u) }, r.toPoints = n, r.valid = function (r) { var e = k(r); return { errors: e, valid: 0 === e.length } }, Object.defineProperty(r, "__esModule", { value: !0 }) });
//# sourceMappingURL=svg-points.min.js.map
